<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" href="https://images.scalebranding.com/line-art-hand-logo-76be523b-4c03-4013-b848-986027d7ef06.jpg">
</head>
<body>

    <div id="ui">
        <h1>Gesture Particles</h1>
        <p>üñê <b>Move Hand:</b> Attract Particles</p>
        <p>üëå <b>Pinch:</b> Switch Shape</p>
        <p>‚úä <b>Fist:</b> Collapse / ‚úã <b>Open:</b> Expand</p>
        <p id="status">Status: Initializing AI...</p>
        <p id="current-shape" style="color: yellow; margin-top:10px;">Shape: SPHERE</p>
    </div>

    <div id="loading">Loading Vision Models...<br><span style="font-size:12px; color: #aaa;">(Please ensure you are using a Local Server)</span></div>

    <div id="video-container">
        <video id="webcam" playsinline></video>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three":"https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.5;
        
        let scene, camera, renderer, particles, geometry, material;
        let positions, colors, initialPositions;
        let targetPositions = []; 
        let currentShapeIndex = 0;
        let isPinching = false;
        let handPosition = new THREE.Vector3(9999, 9999, 9999); 
        let handState = 'OPEN'; 
        let time = 0;

        const SHAPES = ['SPHERE', 'HEART', 'FLOWER', 'SATURN'];
        
        init();
        initMediaPipe();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.03);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const posArray = new Float32Array(PARTICLE_COUNT * 3);
            const colArray = new Float32Array(PARTICLE_COUNT * 3);
            
            const shapeSphere = generateSphere();
            const shapeHeart = generateHeart();
            const shapeFlower = generateFlower();
            const shapeSaturn = generateSaturn();
            
            targetPositions = [shapeSphere, shapeHeart, shapeFlower, shapeSaturn];

            for(let i=0; i < PARTICLE_COUNT * 3; i++) {
                posArray[i] = shapeSphere[i];
                colArray[i] = 1.0; 
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));
            geometry.userData.target = shapeSphere;

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                vertexColors: true,
                alphaTest: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
        }

        function generateSphere() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const r = 10 + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                arr[i*3] = r * Math.sin(phi) * Math.cos(theta);
                arr[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                arr[i*3+2] = r * Math.cos(phi);
            }
            return arr;
        }

        function generateHeart() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                let t = Math.random() * Math.PI * 2;
                const scale = 0.8;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const spread = (Math.random() - 0.5) * 4;
                arr[i*3] = x * scale + spread;
                arr[i*3+1] = y * scale + spread;
                arr[i*3+2] = (Math.random() - 0.5) * 10;
            }
            return arr;
        }

        function generateFlower() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const r = 0.3 * Math.sqrt(i);
                const theta = i * goldenAngle;
                let x = r * Math.cos(theta);
                let y = r * Math.sin(theta);
                let z = Math.sin(r * 0.5) * 5 + (Math.random() - 0.5);
                arr[i*3] = x; arr[i*3+1] = y; arr[i*3+2] = z;
            }
            return arr;
        }

        function generateSaturn() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                if (i < PARTICLE_COUNT * 0.3) {
                    const r = 6;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    arr[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    arr[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    arr[i*3+2] = r * Math.cos(phi);
                } else {
                    const r = 10 + Math.random() * 8;
                    const theta = Math.random() * Math.PI * 2;
                    const x = r * Math.cos(theta);
                    const y = (Math.random() - 0.5) * 0.5;
                    const z = r * Math.sin(theta);
                    const tilt = 0.4;
                    arr[i*3] = x * Math.cos(tilt) - y * Math.sin(tilt);
                    arr[i*3+1] = x * Math.sin(tilt) + y * Math.cos(tilt);
                    arr[i*3+2] = z;
                }
            }
            return arr;
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('webcam');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;

            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').innerText = "Status: Tracking Active";
                })
                .catch(err => {
                    console.error("Camera failed:", err);
                    document.getElementById('status').innerText = "Camera Error: Check Console";
                });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                const x = (0.5 - landmarks[8].x) * 60; 
                const y = (0.5 - landmarks[8].y) * 40; 
                const z = 0; 

                handPosition.x += (x - handPosition.x) * 0.1;
                handPosition.y += (y - handPosition.y) * 0.1;
                handPosition.z = z;

                const thumb = landmarks[4];
                const index = landmarks[8];
                const distance = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                if (distance < 0.05) {
                    if (!isPinching) {
                        isPinching = true;
                        switchShape();
                    }
                } else {
                    isPinching = false;
                }

                const wrist = landmarks[0];
                const tipDist = Math.hypot(index.x - wrist.x, index.y - wrist.y);
                if (tipDist < 0.25) handState = 'CLOSED';
                else handState = 'OPEN';

            } else {
                handPosition.set(9999, 9999, 9999);
            }
        }

        function switchShape() {
            currentShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
            document.getElementById('current-shape').innerText = `Shape: ${SHAPES[currentShapeIndex]}`;

        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const positionsAttribute = geometry.attributes.position;
            const colorsAttribute = geometry.attributes.color;
            const currentPositions = positionsAttribute.array;
            const targetShape = targetPositions[currentShapeIndex];

            const palettes = [
                new THREE.Color(0x00ffff), 
                new THREE.Color(0xff0055), 
                new THREE.Color(0xffff00), 
                new THREE.Color(0xaa00ff)
            ];
            const targetColor = palettes[currentShapeIndex];

            for(let i=0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                currentPositions[ix] += (targetShape[ix] - currentPositions[ix]) * 0.05;
                currentPositions[iy] += (targetShape[iy] - currentPositions[iy]) * 0.05;
                currentPositions[iz] += (targetShape[iz] - currentPositions[iz]) * 0.05;

                const px = currentPositions[ix];
                const py = currentPositions[iy];
                const pz = currentPositions[iz];

                const dx = px - handPosition.x;
                const dy = py - handPosition.y;
                const dz = pz - handPosition.z;
                const distSq = dx*dx + dy*dy + dz*dz;
                
                if (distSq < 100) { 
                    const dist = Math.sqrt(distSq);
                    
                    if (handState === 'CLOSED') {
                        currentPositions[ix] -= dx * 0.1;
                        currentPositions[iy] -= dy * 0.1;
                        currentPositions[iz] -= dz * 0.1;
                    } else {
                        currentPositions[ix] += (dx / dist) * 0.5 + (Math.random()-0.5)*0.2;
                        currentPositions[iy] += (dy / dist) * 0.5 + (Math.random()-0.5)*0.2;
                        currentPositions[iz] += (dz / dist) * 0.5 + (Math.random()-0.5)*0.2;
                    }

                    colorsAttribute.array[ix] = 1.0;
                    colorsAttribute.array[iy] = 1.0;
                    colorsAttribute.array[iz] = 1.0;
                } else {
                    colorsAttribute.array[ix] += (targetColor.r - colorsAttribute.array[ix]) * 0.02;
                    colorsAttribute.array[iy] += (targetColor.g - colorsAttribute.array[iy]) * 0.02;
                    colorsAttribute.array[iz] += (targetColor.b - colorsAttribute.array[iz]) * 0.02;
                }
            }

            particles.rotation.y = time * 0.1;
            particles.rotation.z = time * 0.05;

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>